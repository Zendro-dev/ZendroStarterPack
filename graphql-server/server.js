var express = require("express");
var path = require("path");
var graphqlHTTP = require("express-graphql");
var jwt = require("express-jwt");
const fileUpload = require("express-fileupload");
const auth = require("./utils/login");
const bodyParser = require("body-parser");
const globals = require("./config/globals");
const execute = require("./utils/custom-graphql-execute");
const checkAuthorization = require("./utils/check-authorization");
const helper = require("./utils/helper");
const nodejq = require("node-jq");
const { JSONPath } = require("jsonpath-plus");
const errors = require("./utils/errors");
const { formatError, graphql } = require("graphql");
let models = require(path.join(__dirname, "models", "index.js"));
const initializeStorageHandlersForModels = require(path.join(
  __dirname,
  "utils",
  "helper.js"
)).initializeStorageHandlersForModels;
let adapters = require(path.join(__dirname, "models", "adapters", "index.js"));
const initializeStorageHandlersForAdapters = require(path.join(
  __dirname,
  "utils",
  "helper.js"
)).initializeStorageHandlersForAdapters;

const { graphqlUploadExpress } = require('graphql-upload');

var acl = null;
let resolvers = null;
let simpleExport = null;

var cors = require("cors");

/* Server */
const APP_PORT = globals.PORT;
const app = express();

app.use((req, res, next) => {
  // Website you wish to allow to connect
  if (globals.REQUIRE_SIGN_IN) {
    res.setHeader("Access-Control-Allow-Origin", globals.ALLOW_ORIGIN);
  }
  next();
});

// Force users to sign in to get access to anything else than '/login'
console.log("REQUIRE: ", globals.REQUIRE_SIGN_IN);
if (globals.REQUIRE_SIGN_IN) {
  app.use(jwt({ secret: globals.JWT_SECRET }).unless({ path: ['/login'] }));
}

/* Temporary solution:  acl rules set */
if (process.argv.length > 2 && process.argv[2] == "acl") {
  let node_acl = require("acl");
  let { aclRules } = require("./acl_rules");
  acl = new node_acl(new node_acl.memoryBackend());

  /* set authorization rules from file acl_rules.js */
  acl.allow(aclRules);
  console.log("Authoization rules set!");
} else {
  console.log("Open server, no authorization rules");
}

/* Schema */
console.log("Merging Schema");
let Schema = helper.mergeSchemaSetScalarTypes(
  path.join(__dirname, "./schemas")
);

const { leftShift } = require("mathjs");
/* Parse urlencoded bodies and JSON by bodyParser middlewares*/
app.use(bodyParser.urlencoded({ extended: false }));
app.use(bodyParser.json({ limit: globals.POST_REQUEST_MAX_BODY_SIZE }));

app.use("/login", cors(), async (req, res) => {
  try {
    const token = await auth.login(req.body);
    res.json({ token: token });
  } catch (err) {
    res.status(500).send({ error: `${err}. Please check your credentials.` });
  }
});

app.use("/export", cors(), async (req, res) => {
  //set checker for using in the local method simpleExport
  res["responseSent"] = false;

  //set MAX_TIME_OUT
  res.setTimeout(globals.EXPORT_TIME_OUT * 1000, function () {
    res.end("TIMEOUT EXCEEDS");
  });

  res.on("finish", () => {
    res["responseSent"] = true;
  });

  let context = {
    request: req,
    acl: acl,
    benignErrors: [],
    recordsLimit: globals.LIMIT_RECORDS,
  };

  let body_info = req.query;

  try {
    await simpleExport(context, body_info, res);
    res.end();
  } catch (err) {
    if (!res.responseSent) {
      res.status(500).send(err);
    } else {
      console.error("ERROR IN EXPORT AFTER SENDING THE RESPONSE: " + err);
    }
  }
});

//app.use(fileUpload());
/*request is passed as context by default  */
app.use(
  "/graphql",
  cors(),
  graphqlUploadExpress({ maxFileSize: 10000000, maxFiles: 10 }),
  graphqlHTTP((req) => ({
    schema: Schema,
    rootValue: resolvers,
    pretty: true,
    graphiql: true,
    context: {
      request: req,
      acl: acl,
      benignErrors: [],
      recordsLimit: globals.LIMIT_RECORDS,
    },
    customExecuteFn: execute.execute,
    customFormatErrorFn: function (error) {
      errors.customErrorLog(error); // Will log the error either compact (defualt) or verbose dependent on the env variable "ERROR_LOG"
      let extensions = errors.formatGraphQLErrorExtensions(error);
      return {
        message: error.message,
        locations: error.locations ? error.locations : "",
        // Either use the extensions of a remote error, or
        // the local originalError.errors generated by for example validation Errors (AJV):
        extensions: extensions,
        path: error.path,
      };
    },
  }))
);

let metaQueryCorsOptions = {
  allowedHeaders: ["Content-Type", "Authorization", "jq", "jsonPath"],
};
app.options("/meta_query", cors(metaQueryCorsOptions));
app.post("/meta_query", cors(), async (req, res, next) => {
  try {
    let context = {
      request: req,
      acl: acl,
      benignErrors: [],
      recordsLimit: globals.LIMIT_RECORDS,
    };

    if (req != null) {
      const query = req.body.query;
      const jq = req.headers.jq;
      const jsonPath = req.headers.jsonpath;
      const variables = req.body.variables;

      helper.eitherJqOrJsonpath(jq, jsonPath);

      const graphQlResponse = await graphql(
        Schema,
        query,
        resolvers,
        context,
        variables
      );

      let output = graphQlResponse.data;
      const resolversHaveData = output ? Object.values(output).some((val) => val) : null;

      if (resolversHaveData) {
        if (helper.isNotUndefinedAndNotNull(jq)) {
          // jq
          output = await nodejq.run(jq, graphQlResponse.data, { input: "json", output: "json" });
        } else {
          // JSONPath
          output = JSONPath({
            path: jsonPath,
            json: graphQlResponse.data,
            wrap: false,
          });
        }
      }

      res.json({ data: output, errors: graphQlResponse.errors });

      next();
    }
  } catch (error) {
    res.json({ data: null, errors: [formatError(error)] });
  }
});
/**
 * uncaughtException handler needed to prevent node from crashing upon receiving a malformed jq filter.
 */
process.on("uncaughtException", (err) => {
  console.log("!!uncaughtException:", err);
});

// Error handling
app.use(function (err, req, res, next) {
  if (err.name === "UnauthorizedError") {
    // Send the error rather than to show it on the console
    res.status(401).send(err);
  } else {
    next(err);
  }
});

var server = app.listen(APP_PORT, async () => {
  await initializeStorageHandlersForModels(models);
  await initializeStorageHandlersForAdapters(adapters);
  resolvers = require("./resolvers/index");
  simpleExport = require("./utils/simple-export");
  console.log(`App listening on port ${APP_PORT}`);
});

module.exports = server;
